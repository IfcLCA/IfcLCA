import { type PyodideInterface } from "pyodide";

declare global {
  interface Window {
    loadPyodide?: (config?: { indexURL?: string }) => Promise<PyodideInterface>;
    pyodide?: PyodideInterface;
  }
}

const PYODIDE_INDEX_URL = "https://cdn.jsdelivr.net/pyodide/v0.26.2/full/";
const IFC_OPEN_SHELL_WHEEL_URL =
  "https://cdn.jsdelivr.net/gh/IfcOpenShell/wasm-wheels@main/ifcopenshell-0.8.2+d50e806-cp312-cp312-emscripten_3_1_58_wasm32.whl";

let pyodidePromise: Promise<PyodideInterface> | null = null;
let pythonScriptLoaded = false;

async function ensurePyodideLoader(): Promise<void> {
  if (typeof window.loadPyodide === "function") {
    return;
  }

  await new Promise<void>((resolve, reject) => {
    const script = document.createElement("script");
    script.src = `${PYODIDE_INDEX_URL}pyodide.js`;
    script.async = true;
    script.onload = () => resolve();
    script.onerror = () => reject(new Error("Failed to load Pyodide script"));
    document.head.appendChild(script);
  });
}

async function getPyodideInstance(): Promise<PyodideInterface> {
  if (!pyodidePromise) {
    pyodidePromise = (async () => {
      await ensurePyodideLoader();
      if (!window.loadPyodide) {
        throw new Error("Pyodide loader not available on window");
      }

      const pyodide = await window.loadPyodide({ indexURL: PYODIDE_INDEX_URL });

      await pyodide.loadPackage("micropip");
      const micropip = pyodide.pyimport("micropip");
      await micropip.install(IFC_OPEN_SHELL_WHEEL_URL);

      window.pyodide = pyodide;
      return pyodide;
    })();
  }

  return pyodidePromise;
}

const PYTHON_IFC_PROCESSING_SCRIPT = `
import ifcopenshell
import ifcopenshell.guid
import ifcopenshell.util.element
import json
import time

TEMP_IFC_PATH = "/home/pyodide/temp_model.ifc"
PSET_NAME = "CPset_IfcLCA"


def get_or_create_owner_history(model):
    owner_history = model.by_type("IfcOwnerHistory")
    if owner_history:
        return owner_history[0]

    person = model.create_entity(
        "IfcPerson",
        Identification="N/A",
        GivenName="IfcLCA",
        FamilyName="User",
    )
    organization = model.create_entity(
        "IfcOrganization",
        Name="IfcLCA",
        Description="Generated by IfcLCA export",
    )
    person_and_org = model.create_entity(
        "IfcPersonAndOrganization",
        ThePerson=person,
        TheOrganization=organization,
    )
    developer_org = model.create_entity(
        "IfcOrganization",
        Name="IfcLCA Export Service",
    )
    application = model.create_entity(
        "IfcApplication",
        ApplicationDeveloper=developer_org,
        Version="1.0",
        ApplicationFullName="IfcLCA Export",
        ApplicationIdentifier="ifclca.export",
    )
    current_time = int(time.time())

    return model.create_entity(
        "IfcOwnerHistory",
        OwningUser=person_and_org,
        OwningApplication=application,
        State="READWRITE",
        ChangeAction="MODIFIED",
        CreationDate=current_time,
    )


def export_ifc_with_lca_results(ifc_file_uint8array_js, lca_json_str):
    try:
        ifc_file_bytes = bytes(ifc_file_uint8array_js.to_py())
        with open(TEMP_IFC_PATH, "wb") as f:
            f.write(ifc_file_bytes)

        model = ifcopenshell.open(TEMP_IFC_PATH)
        if not model:
            return {"error": "Failed to open IFC model."}

        owner_history = get_or_create_owner_history(model)
        lca_data = json.loads(lca_json_str)

        updated_count = 0
        missing_guids = []

        for guid, metrics in lca_data.items():
            element = model.by_guid(guid)
            if not element:
                missing_guids.append(guid)
                continue

            values = {}
            if metrics.get("gwp") is not None:
                values["GWP_fossil"] = float(metrics["gwp"])
            if metrics.get("penre") is not None:
                values["non-renewableprimaryresourceswithenergycontent-tot"] = float(metrics["penre"])
                # Provide duplicate key for potential without energy content if required
                values.setdefault("non-renewableprimaryresourceswithoutenergycontent-tot", float(metrics["penre"]))
            if metrics.get("ubp") is not None:
                values["UBP"] = float(metrics["ubp"])

            if not values:
                continue

            ifcopenshell.util.element.set_pset(
                model,
                element,
                PSET_NAME,
                values,
                overwrite=True,
                ifc_owner_history=owner_history,
                is_custom_pset=True,
            )
            updated_count += 1

        return {
            "ifcData": model.to_string(),
            "updatedCount": updated_count,
            "missingGuids": missing_guids,
        }

    except Exception as e:
        import traceback
        return {
            "error": f"Python error during IFC processing: {str(e)}",
            "traceback": traceback.format_exc(),
        }
`;

export interface ElementLcaExportValue {
  guid: string;
  gwp: number;
  penre: number;
  ubp: number;
}

export type ElementLcaExportMap = Record<string, ElementLcaExportValue>;

export interface ExportIfcWithLcaResult {
  ifcData: string;
  updatedCount: number;
  missingGuids: string[];
}

export async function exportIfcWithLcaResultsService(
  ifcFileBuffer: ArrayBuffer,
  elementData: ElementLcaExportMap
): Promise<ExportIfcWithLcaResult | null> {
  try {
    const pyodide = await getPyodideInstance();

    if (!pythonScriptLoaded) {
      pyodide.runPython(PYTHON_IFC_PROCESSING_SCRIPT);
      pythonScriptLoaded = true;
    }

    const processIfcFunction = pyodide.globals.get(
      "export_ifc_with_lca_results"
    );

    const jsUint8Array = new Uint8Array(ifcFileBuffer);
    const payload = Object.fromEntries(
      Object.entries(elementData).map(([guid, metrics]) => [guid, metrics])
    );
    const lcaJsonStr = JSON.stringify(payload);

    const resultProxy = await processIfcFunction(jsUint8Array, lcaJsonStr);
    const resultJS = resultProxy.toJs({ dict_converter: Object.fromEntries });
    resultProxy.destroy();

    if (resultJS.error) {
      console.error("Python script execution failed:", resultJS.error);
      if (resultJS.traceback) {
        console.error(resultJS.traceback);
      }
      return null;
    }

    if (resultJS.ifcData) {
      return {
        ifcData: resultJS.ifcData as string,
        updatedCount: Number(resultJS.updatedCount || 0),
        missingGuids: Array.isArray(resultJS.missingGuids)
          ? (resultJS.missingGuids as string[])
          : [],
      };
    }

    console.error("Python script did not return IFC data.");
    return null;
  } catch (error) {
    console.error("Error during IFC export process:", error);
    pyodidePromise = null;
    pythonScriptLoaded = false;
    return null;
  }
}

export function downloadFile(
  content: BlobPart,
  fileName: string,
  contentType: string
) {
  const a = document.createElement("a");
  const file = new Blob([content], { type: contentType });
  a.href = URL.createObjectURL(file);
  a.download = fileName;
  document.body.appendChild(a);
  a.click();
  URL.revokeObjectURL(a.href);
  document.body.removeChild(a);
}
